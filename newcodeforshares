import random
import matplotlib.pyplot as plt
import numpy as np
from itertools import permutations

def generate_polynomial(secret, degree):
    coefficients = [secret]
    for _ in range(degree):
        coefficients.append(random.randint(1, 100))
    return coefficients

def evaluate_polynomial(coefficients, x):
    result = 0
    for i, coeff in enumerate(coefficients):
        result += coeff * (x ** i)
    return result

def generate_shares(secret, n, k):
    if k < 2:
        raise ValueError("Threshold k must be at least 2.")
    polynomial = generate_polynomial(secret, degree=k-1)
    shares = [(i, evaluate_polynomial(polynomial, i)) for i in range(1, n + 1)]
    return shares, polynomial

def lagrange_interpolation(x, points):
    total = 0
    n = len(points)
    for i in range(n):
        xi, yi = points[i]
        term = yi
        for j in range(n):
            if i != j:
                xj, _ = points[j]
                if xi == xj:
                    raise ValueError("Duplicate x values found in points.")
                term *= (x - xj) / (xi - xj)
        total += term
    return total

def reconstruct_secret(shares, k):
    points = shares[:k]
    return lagrange_interpolation(0, points)

def plot_shares_with_permutations(shares, polynomial, user_point):
    x_values = [share[0] for share in shares]
    y_values = [share[1] for share in shares]

    plt.figure(figsize=(10, 6))
    
    x_range = np.linspace(min(x_values) - 1, max(x_values) + 1, 500)
    y_range = [evaluate_polynomial(polynomial, x) for x in x_range]
    plt.plot(x_range, y_range, 'b--', label='Polynomial')
    
    secret = evaluate_polynomial(polynomial, 0)
    plt.scatter(0, secret, color='red', label=f'f(0) = {secret}', zorder=5)

    user_x, user_y = user_point
    shares.append(user_point)
    
    valid_permutations = [perm for perm in permutations(shares, 3) if user_point in perm and len(set(p[0] for p in perm)) == 3]
    
    colors = plt.cm.jet(np.linspace(0, 1, len(valid_permutations)))
    
    for idx, perm in enumerate(valid_permutations):
        perm_x_values = [point[0] for point in perm]
        perm_y_values = [point[1] for point in perm]
        
        try:
            reconstructed_secret = lagrange_interpolation(0, perm)
            plt.plot(perm_x_values, perm_y_values, '-o', color=colors[idx], label=f'Perm {idx+1}, f(0)={reconstructed_secret:.2f}')
        except ValueError as e:
            print(f"Skipping invalid permutation: {perm} ({e})")
    
    plt.title('Shamir Secret Sharing Permutations')
    plt.xlabel('x')
    plt.ylabel('f(x)')
    plt.legend()
    plt.grid(True)
    plt.show()

def main():
    secret = int(input('Enter your Secret: '))
    n = int(input('Enter Total Number of Shares n: '))  # Total number of shares
    k = int(input('Enter Threshold k (>2): '))  # Threshold to reconstruct the secret

    shares, polynomial = generate_shares(secret, n, k)

    for share in shares:
        print(f"Share {share[0]}: {share[1]}")
    
    user_x = int(input("Enter x value to verify: "))
    user_y = int(input("Enter y value to verify: "))
    
    if np.isclose(evaluate_polynomial(polynomial, user_x), user_y):
        print("The provided value lies on the polynomial.")
    else:
        print("The provided value does not lie on the polynomial.")
    
    plot_shares_with_permutations(shares, polynomial, user_point=(user_x, user_y))
    
    reconstructed_secret = reconstruct_secret(shares, k)
    print(f"Reconstructed Secret: {reconstructed_secret}")

if __name__ == "__main__":
    main()
